package trivyhelper

import (
	"context"
	"os"

	"github.com/aquasecurity/trivy/pkg/commands/artifact"
	"github.com/aquasecurity/trivy/pkg/flag"
	"github.com/aquasecurity/trivy/pkg/types"
)

var (
	version     string                = "dev"
	globalFlags *flag.GlobalFlagGroup = flag.NewGlobalFlagGroup()
)

func ScanImage(ctx context.Context, image string) (types.Report, error) {

	options, err := createImageFlags().ToOptions(version, []string{image}, globalFlags, os.Stdout)
	if err != nil {
		return types.Report{}, err
	}

	ctx, cancel := context.WithTimeout(ctx, options.Timeout)
	defer cancel()

	r, err := artifact.NewRunner(ctx, options)
	if err != nil {
		return types.Report{}, err
	}
	defer r.Close(ctx)

	var report types.Report
	if report, err = r.ScanImage(ctx, options); err != nil {
		return types.Report{}, err
	}

	report, err = r.Filter(ctx, options, report)
	if err != nil {
		return types.Report{}, err
	}

	return report, nil
}

func createImageFlags() *flag.Flags {
	reportFlagGroup := flag.NewReportFlagGroup()
	reportFlagGroup.ReportFormat = nil

	return &flag.Flags{
		CacheFlagGroup:         flag.NewCacheFlagGroup(),
		DBFlagGroup:            flag.NewDBFlagGroup(),
		ImageFlagGroup:         flag.NewImageFlagGroup(), // container image specific
		LicenseFlagGroup:       flag.NewLicenseFlagGroup(),
		MisconfFlagGroup:       flag.NewMisconfFlagGroup(),
		RemoteFlagGroup:        flag.NewClientFlags(), // for client/server mode
		RegoFlagGroup:          flag.NewRegoFlagGroup(),
		ReportFlagGroup:        reportFlagGroup,
		ScanFlagGroup:          flag.NewScanFlagGroup(),
		SecretFlagGroup:        flag.NewSecretFlagGroup(),
		VulnerabilityFlagGroup: flag.NewVulnerabilityFlagGroup(),
	}
}
